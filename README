Need to rewrite:

1. Word Ladder---> finished in May 23. BFS
2. Word Ladder2
3. Longest Palindrome
4. LRU cache  ---> implement with doubly linked list
5. Binary Tree Inorder
6. Word Break
7. Word Break2
8. Copy List With Random Pointer 
9. Single number2 ----> from binary to ternary (bit manupulation)
10. Candy ----> Scan twice   (Trapping rain water ---> scan twice)
11. Clone Graph
12. Binary maximum Path sum--->(recursion) max(left + right + root, math.max(left, right)+root)--> finished in May24th
13. Best time to sell stock 3
14. Triangle (DP)
15. Pascal Triangle (iteration)


Heap vs Stack -----> heap memory allocation is dynamic. Stack memory allocation is fixed. 
                     If there are not enough memory, stack overflow will happen.
Problem with heap--> fragmentation---> on system with virtual memory, fragmentation is less of a problem that we can think of. 
Since though physical memory is in fragmentation state, but in virtual memory it still works..

The access speed for stack should be faster. 
In a multi-threaded app, each thread will have its own stack, but share same heap. 
In c++, object can be stored in stack. If create an object inside a function without using "new". -----> create object on the stack, not on heap.
In c++, any data on the stack created specifically for that function call will automatically be deleted. Data on heap will remain until it's manually
deleted.

Similar--> They are both stored in computer's RAM

Iterative vs Recursion----> recursion use too much memory space. Just a few language has tail-optimization which is efficient for recursion. 

Master theorem provides us a way to evaluate certain recurrences. ----> solve big O notation for recursion.


Unit Test:
extending TestCase is the way unit tests were written in Junit 3
using @test annotation is the way introduced by JUnit 4.

Compare public, protected, default, private----->

Modifier    | Class | Package | Subclass | World
————————————+———————+—————————+——————————+———————
public      |  y    |    y    |    y     |   y
————————————+———————+—————————+——————————+———————
protected   |  y    |    y    |    y     |   n
————————————+———————+—————————+——————————+———————
no modifier |  y    |    y    |    n     |   n
————————————+———————+—————————+——————————+———————
private     |  y    |    n    |    n     |   n                y denotes accessible, no denotes inaccessible.

Type erasure applied to use of generics. Compiled generic code just uses java.lang.Object wherever we talk
about T and there's some metadata to tell the compiler that it really is a generic type.
At execution time, List<String> and List<Date> are exactly the same. Extra information has been erased by the compiler.

When using genrics to build our class, when we use constructor, we don't put generics 

Synchronized Singleton:
private static YourObject instance;

public static synchronized YourObject getInstance() {
        if(instance == null) {
                    instance = new YourObject();
                        }
                            return instance;
}


Heap sort in java:
PriorityQueue<String> p  = new PriorityQueue<String>(10, new Comparator<String>(){
                           public int compare(Sring x, String y){
                            if (x.length < y.length())
                            {
                                return -1 ;
                            }
                            **
                            }}
                            );

MinHeap: each node is greater or equal than its parent.

In C++, unsigned numbers can't overflow. When unsigned int is 32 bit, result = (a*b) mod 2^32
However, for signed integer, overflow cause undefined behavior.
In java, if it is overflow, it goes back to underflow condition.

Hashtable is a data structure that maps keys to values for highly efficient lookup. 
--> Hashtable has an underlying arrray and a hash function. When we insert a key and value, 
the hash function maps the key to an integer, indicate the index in the array. Object is then 
stored at that index;
hashvalue of all keys should be unique. To avoid hash collision, we need to consider insert a
linkedlist in each index. 

virtual in c++: it defines a class in super class, and this helps its subclass to override it.

Dependency injection: better for test. Pass the object directly into constructor.

Graph---> a bunch of verticles connected by edges;
Graph can be represented by pair (V,E)
Degree---> for undirected graph--> Degree of a vertex is the number of edges touching it.
           for directed graoh--> in-Degree is the number of edges entering the vertex, out-degree is number of e out.
we can write u => v if there is a path from u to v;   v is reachable from u.
a cycle is a path of length at least 1 from a vertex to itself;
graph with no cycles is acyclic;
path with no cycle is a simple path;

For undirected graph is connected iff there is a path between any two verticles;
a free tree is a connected, acyclic, undirected graph --> E = V-1, any two verticles are connected by exactly one path.
If the graph is disconnected, it's a forest;
addding an edge result in a cycle in free tree;

DFS:
DFS(G)
for each vertex u in V[G]
    do color[u] is WHITE
        u.parent = NIL
for each vertex u in V[G]
    do if u.color = WHITE
        then DFS-VISIT(u)
DFS-VISIT(u)
    u.color = gray;
    for each v in u.adj 
        do if v.color == WHITE
            then v.parent = u
                DFS-VISIT(v)
    u.color = BLACK

On an undirected graph, any edge that is not a "tree" edge is a "back" edge (from descendant to ancestor)
For directed graphs: if we visit the vertex while it is still GRAY, we have a back edge.

Topological sort---> related to finishing time.

Running time of DFS is O(V+E).---> for Graph
Cycle detection in graph: if the graph is undirected, then dfs returns to a vertex it has visited, there is a cycle;
                          However, for directed graph, it is not right ---> a graph G contains cycle if and only if a DFS of G yields a back edge.---> back edge
                          How to detect back-edge in DFS ---->


MVC---> model view and controller ----> controller will handle IO between "views", model is the application logic and state, view is representation of state in model.

gem--> a piece of ruby code packaged as a library so that it can be imported and used by other program.
popular gem--> rails, activerecord, rake. Rubygems is the name of the project that wrote the "gem" ruby library.
Symbol vs String --> :"**" vs "**"--> string is mutable and memory for string is released every time, for symbol memory is not released each time.Use the same heap location.
Instance variable ---> @     Global variable ---> $  
Constructor in Ruby---> initialize
Overloading in Ruby is not supported. it does support the overall goal of passing variable number of parameters to the same method.



Rails--> web application framework in Ruby. --> teo major principles (don't repeat yourself, convention over configuration)
rails server --> this can fire up WEBrick--> a web server distributed with Ruby by default. 
a view's purpose is to display information in human readable format. View templates are written in eRuby--> embedded Ruby. 

To create a new controller, we need to run the "controller" generator--> rails generate controller welcome index --> index is the action


Angular JS: 1. MVC --> split app into mvc component;    2. unit test ready  3. a declarative user interface 4. data are POJO
             

In java, Map is an interface, HashMap is a class. 
HashMap is not Synchronized, hashtable is.

Trie(prefix tree) is a good data structure for building a memory-efficient dictionary with fast lookups.----> it likes a hashtable,but with sorted keys
