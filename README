Need to rewrite:

1. Word Ladder---> finished in May 23. BFS
2. Word Ladder2
3. Longest Palindrome
4. LRU cache
5. Binary Tree Inorder
6. Word Break
7. Word Break2
8. Copy List With Random Pointer 
9. Single number2 ----> from binary to ternary (bit manupulation)
10. Candy ----> Scan twice   (Trapping rain water ---> scan twice)
11. Clone Graph
12. Binary maximum Path sum--->(recursion) max(left + right + root, math.max(left, right)+root)--> finished in May24th
13. Best time to sell stock 3
14. Triangle (DP)
15. Pascal Triangle (iteration)


Heap vs Stack -----> heap memory allocation is dynamic. Stack memory allocation is fixed. 
                     If there are not enough memory, stack overflow will happen.
Problem with heap--> fragmentation---> on system with virtual memory, fragmentation is less of a problem that we can think of. 
Since though physical memory is in fragmentation state, but in virtual memory it still works..

The access speed for stack should be faster. 
In a multi-threaded app, each thread will have its own stack, but share same heap. 
In c++, object can be stored in stack. If create an object inside a function without using "new". -----> create object on the stack, not on heap.
In c++, any data on the stack created specifically for that function call will automatically be deleted. Data on heap will remain until it's manually
deleted.

Similar--> They are both stored in computer's RAM

Iterative vs Recursion----> recursion use too much memory space. Just a few language has tail-optimization which is efficient for recursion. 

Master theorem provides us a way to evaluate certain recurrences. ----> solve big O notation for recursion.


Unit Test:
extending TestCase is the way unit tests were written in Junit 3
using @test annotation is the way introduced by JUnit 4.

Compare public, protected, default, private----->

Modifier    | Class | Package | Subclass | World
————————————+———————+—————————+——————————+———————
public      |  y    |    y    |    y     |   y
————————————+———————+—————————+——————————+———————
protected   |  y    |    y    |    y     |   n
————————————+———————+—————————+——————————+———————
no modifier |  y    |    y    |    n     |   n
————————————+———————+—————————+——————————+———————
private     |  y    |    n    |    n     |   n                y denotes accessible, no denotes inaccessible.

Type erasure applied to use of generics. Compiled generic code just uses java.lang.Object wherever we talk
about T and there's some metadata to tell the compiler that it really is a generic type.
At execution time, List<String> and List<Date> are exactly the same. Extra information has been erased by the compiler.

When using genrics to build our class, when we use constructor, we don't put generics 
